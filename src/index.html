<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
</head>
<body>
<br>
<input type="file" id="uploadFile" name="file" />
<br><br>
<label for="deviceID">Device ID:</label><br>
<input type="text" id="deviceID" name="deviceID" value=""><br>
<span id="uploadButton">
    <button id="upload">Upload</button>
</span>  
<br><br>
<span id="getSizeButton">
    <button id="fileSize">get file size</button>
</span>  
<br><br>
Max file size: <output id="MaxFileSize"></output>
<br><br>
<span id="boardListButton">
    <button id="boardList">Board list</button>
</span>
<span id="cancelButton" style="display: none;">
  <button id="cancel" style="color: red">CANCEL</button>
</span>
<br>
<br>
Boards: <output id="boards"></output>
</body>
<script>
    var curDeviceID;
    var file;
    var filePos;
    var cancel = false;
    var reader;
    var blob;
    var boardsArr = [];
    //Event is used to wrap all messages Send and Recieved
    //on the Websocket
        //The type is used as a RPC
    class Event {
        // Each Event needs a Type
        // The payload is not required
        constructor(type, payload) {
            this.type = type;
            this.payload = payload;
        }
    }
    class Device {
        constructor(id, name, controller, programmer, port, serialID){
            this.deviceID = id;
            this.name = name;
            this.controller = controller;
            this.programmer = programmer;
            this.portName = port; 
            this.sierialID = serialID; 
        }
    }
    class FlashStart {
        constructor(id, fileSize){
            this.deviceID = id;
            this.fileSize = fileSize;
        }
    }
    class FlashBlock{
        constructor(blockID, data){
            this.blockID = blockID;
            this.data = data;
        }
    }
    class MaxFS{
        constructor(size){
            this.size = size
        }
    }
    function routeEvent(event) {
        if (event.type === undefined) {
            alert("no 'type' field in event");
        }
        switch (event.type) {
            case "device":
                // Format payload
                var deviceEvent = Object.assign(new Device, event.payload);
                document.getElementById('boards').innerHTML = '';
                correctString = "[name: " + deviceEvent.name +  ", deviceID: " + deviceEvent.deviceID  + ", controller: " + deviceEvent.controller + ", programmer: " + deviceEvent.programmer + ", port: " + deviceEvent.portName + ", serial: ",  deviceEvent.serialID + "]"
                boardsArr.push(correctString)
                document.getElementById('boards').innerHTML = '<ul>' + boardsArr + '</ul>';
                break;
            case "flash-next-block":
                var blockSize = 1024;
                var first = filePos;
                var last = first + blockSize
                if (last > file.size) {
                    last = file.size;
                }
                blob = file.slice(first, last);
                reader.readAsArrayBuffer(blob);
                break;
            case "flash-done":
                alert("flash-done!")
                break;
            case "flash-wrong-id":
                alert("wrong id");
                break;
            case "flash-disconnected":
                alert("device is disconnected");
                break;
            case "flash-not-finished":
                alert("not finished");
                break;
            case "flash-not-started":
                alert("not started");
                break;
            case "flash-blocked":
                alert("flash blocked");
                break;
            case "flash-large-file":
                alert("file is too large");
                break;
            case "event-not-supported":
                alert("event is not supported");
                break;
            case "unmarshal-err":
                alert("unmarshal");
                break;
            case "device-update-delete":
                deviceDeleted = Object.assign(new Device, event.payload);
                alert("device deleted " + deviceDeleted.deviceID);
                break;
            case "device-update-port":
                devicePorted = Object.assign(new Device, event.payload);
                alert("device update port " + devicePorted.deviceID);
            break;
            case "device-occupied":
                deviceOccupied = Object.assign(new Device, event.payload);
                alert("device occupied " + deviceOccupied.deviceID);
                break;
            case "device-realised":
                deviceRealised = Object.assign(new Device, event.payload);
                alert("device realised " + deviceRealised.deviceID);
                break;
            case "max-file-size":
                maxsize = Object.assign(new MaxFS, event.payload);
                document.getElementById('MaxFileSize').innerHTML = '<ul>' +  maxsize.size + '</ul>';
                break;
            default:
                alert("unsupported message type");
                break;
        }
    }
    function sendEvent(eventName, payload) {
        // Create a event Object with a event named send_message
        const event = new Event(eventName, payload);
        // Format as JSON and send
        conn.send(JSON.stringify(event));
        console.log(JSON.stringify(event));
    }
 
    window.onload = function (){
        // Check if the browser supports WebSocket
        if (window["WebSocket"]) {
            console.log("supports websockets");
            // Connect to websocket
            conn = new WebSocket("ws://" + document.location.host + "/flasher");
            conn.binaryType = 'arraybuffer';
            // Add a listener to the onmessage event
            conn.onmessage = function (evt) {
                console.log(evt);
                // parse websocket message as JSON
                const eventData = JSON.parse(evt.data);
                // Assign JSON data to new Event Object
                const event = Object.assign(new Event, eventData);
                // Let router manage message
                routeEvent(event);
            }
            //document.getElementById('deviceID').onsubmit = uploadFile();
            document.querySelector('#boardList').addEventListener('click', function(evt){
                boardsArr = [];
                document.getElementById('boards').innerHTML = '<ul>' + '</ul>';
                sendEvent('get-list', '');
            }, false);
            document.querySelector('#upload').addEventListener('click',function(evt){
                var files = document.getElementById('uploadFile').files;
                if (!files.length) {
                    alert('Please select a file!');
                    return;
                }
                file = files[0];
                curDeviceID = document.getElementById('deviceID').value;
                msgData = new FlashStart(curDeviceID, file.size);
                filePos = 0;
                reader = new FileReader();
                reader.onloadend = function(evt) {
                    if (evt.target.readyState == FileReader.DONE) {
                        console.log("BLOB")
                        conn.send(blob);
                        filePos += blob.size;
                    }
                };
                sendEvent("flash-start", msgData);
            }, false);
            document.querySelector('#fileSize').addEventListener('click', function(evt){
                sendEvent('get-max-file-size', '');
            }, false);
        } else {
            alert("Not supporting websockets");
        }
        
    };
</script>
</html>
